require "fileutils"
require "date"

require_relative "struct"

module Lazuli
  class TypeGenerator
    TYPE_MAP = {
      String => "string",
      Integer => "number",
      Float => "number",
      Numeric => "number",
      TrueClass => "boolean",
      FalseClass => "boolean",
      Time => "string",
      Date => "string",
      DateTime => "string"
    }.freeze

    def self.generate(app_root:, out_path:)
      new(app_root: app_root, out_path: out_path).generate
    end

    def initialize(app_root:, out_path:)
      @app_root = File.expand_path(app_root)
      @out_path = File.expand_path(out_path)
    end

    def generate
      load_app_structs
      declarations = build_declarations
      FileUtils.mkdir_p(File.dirname(@out_path))
      File.write(@out_path, declarations)
    end

    private

    def load_app_structs
      $LOAD_PATH.unshift(@app_root) unless $LOAD_PATH.include?(@app_root)
      files = Dir[File.join(@app_root, "app", "structs", "**", "*.rb")].sort
      remaining = files.dup

      loop do
        loaded_in_pass = 0
        remaining.dup.each do |file|
          begin
            require file
            remaining.delete(file)
            loaded_in_pass += 1
          rescue NameError
            next
          end
        end
        break if remaining.empty?
        if loaded_in_pass.zero?
          raise "Unable to load structs due to unresolved constants: #{remaining.join(', ')}"
        end
      end
    end

    def build_declarations
      structs = ObjectSpace.each_object(Class).select { |c| c < Lazuli::Struct }
      seen = {}
      lines = ["// Generated by lazuli types", "// DO NOT EDIT MANUALLY", ""]

      structs.sort_by(&:name).each do |struct|
        key = struct.name
        next if seen[key]
        seen[key] = true
        lines << "export interface #{struct.name.split('::').last} {"
        struct.schema.each do |name, type|
          ts_type = map_type(type)
          lines << "  #{name}: #{ts_type};"
        end
        lines << "}"
        lines << ""
      end

      lines.join("\n")
    end

    def map_type(type)
      return "any" if type.nil?
      return "null" if type == NilClass

      if type.is_a?(Array)
        mapped = type.map { |t| map_type(t) }.compact.uniq
        return "any" if mapped.empty?

        null_part = mapped.delete("null") ? " | null" : ""
        return "#{mapped.first}[]#{null_part}" if mapped.size == 1
        return "(#{mapped.join(' | ')})[]#{null_part}"
      end

      TYPE_MAP.each do |ruby_type, ts_type|
        return ts_type if type <= ruby_type rescue false
      end

      return "any[]" if type == Array

      if defined?(Lazuli::Struct) && type.respond_to?(:<) && type < Lazuli::Struct
        return type.name.split("::").last
      end

      "any"
    end
  end
end
