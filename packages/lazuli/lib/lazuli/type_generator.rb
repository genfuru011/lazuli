require "fileutils"
require "date"

require_relative "struct"
require_relative "types"
require_relative "resource"

module Lazuli
  class TypeGenerator
    TYPE_MAP = {
      String => "string",
      Integer => "number",
      Float => "number",
      Numeric => "number",
      TrueClass => "boolean",
      FalseClass => "boolean",
      Time => "string",
      Date => "string",
      DateTime => "string"
    }.freeze

    def self.generate(app_root:, out_path:)
      new(app_root: app_root, out_path: out_path).generate
    end

    def initialize(app_root:, out_path:)
      @app_root = File.expand_path(app_root)
      @out_path = File.expand_path(out_path)
    end

    def generate
      load_app_structs
      load_app_resources
      declarations = build_declarations
      FileUtils.mkdir_p(File.dirname(@out_path))
      File.write(@out_path, declarations)

      rpc_client = build_rpc_client(type_import_path: "./client.d.ts")
      if rpc_client
        out_dir = File.dirname(@out_path)
        File.write(File.join(out_dir, "client.rpc.ts"), rpc_client)

        app_dir = File.join(@app_root, "app")
        FileUtils.mkdir_p(app_dir)
        File.write(File.join(app_dir, "client.rpc.ts"), build_rpc_client(type_import_path: "../client.d.ts"))
      end
    end

    private

    def load_app_structs
      $LOAD_PATH.unshift(@app_root) unless $LOAD_PATH.include?(@app_root)
      files = Dir[File.join(@app_root, "app", "structs", "**", "*.rb")].sort
      remaining = files.dup

      loop do
        loaded_in_pass = 0
        remaining.dup.each do |file|
          begin
            require file
            remaining.delete(file)
            loaded_in_pass += 1
          rescue NameError
            next
          end
        end
        break if remaining.empty?
        if loaded_in_pass.zero?
          raise "Unable to load structs due to unresolved constants: #{remaining.join(', ')}"
        end
      end
    end

    def build_declarations
      structs = ObjectSpace.each_object(Class).select { |c| c < Lazuli::Struct }
      resources = ObjectSpace.each_object(Class).select { |c| defined?(Lazuli::Resource) && c < Lazuli::Resource }
      @interface_names = build_interface_names(structs)
      @rpc_defs = collect_rpc_defs(resources)

      seen = {}
      lines = ["// Generated by lazuli types", "// DO NOT EDIT MANUALLY", ""]

      structs.sort_by(&:name).each do |struct|
        key = struct.name
        next if seen[key]
        seen[key] = true

        lines << "export interface #{interface_name_for(struct)} {"
        struct.schema.each do |name, type|
          ts_type = map_type(type)
          lines << "  #{name}: #{ts_type};"
        end
        lines << "}"
        lines << ""
      end

      rpc_lines = build_rpc_declarations(@rpc_defs)
      lines.concat(rpc_lines) unless rpc_lines.empty?

      lines.join("\n")
    end

    def load_app_resources
      files = Dir[File.join(@app_root, "app", "resources", "**", "*.rb")].sort
      files.each do |file|
        begin
          require file
        rescue StandardError
          # Best-effort: resources may reference unresolved constants; structs should still generate.
          next
        end
      end
    end

    def collect_rpc_defs(resources)
      defs = []
      resources.sort_by(&:name).each do |resource|
        next unless resource.respond_to?(:rpc_definitions)
        resource.rpc_definitions.each do |name, opts|
          key = "#{resource.rpc_key}##{name}"
          req = opts.key?(:params) ? map_type(opts[:params]) : "undefined"
          res = opts.key?(:returns) ? map_type(opts[:returns]) : "any"
          defs << { key: key, request: req, response: res }
        end
      end
      defs
    end

    def build_rpc_declarations(defs)
      return [] if defs.empty?

      lines = [
        "// RPC request/response types (from Resource.rpc)",
        "export interface RpcRequests {"
      ]
      defs.sort_by { |d| d[:key] }.each do |d|
        lines << "  \"#{d[:key]}\": #{d[:request]};"
      end
      lines << "}"
      lines << ""

      lines << "export interface RpcResponses {"
      defs.sort_by { |d| d[:key] }.each do |d|
        lines << "  \"#{d[:key]}\": #{d[:response]};"
      end
      lines << "}"
      lines << ""
      lines
    end

    def build_rpc_client(type_import_path:)
      defs = @rpc_defs || []
      return nil if defs.empty?

      <<~TS
        // Generated by lazuli types
        // DO NOT EDIT MANUALLY
        import type { RpcRequests, RpcResponses } from "#{type_import_path}";

        export type RpcKey = keyof RpcResponses & keyof RpcRequests;

        export type RpcClientOptions = {
          baseUrl?: string;
          headers?: HeadersInit;
        };

        export async function rpc<K extends RpcKey>(
          key: K,
          params: RpcRequests[K],
          options: RpcClientOptions = {},
        ): Promise<RpcResponses[K]> {
          const baseUrl = options.baseUrl ?? "";
          const res = await fetch(`${baseUrl}/__lazuli/rpc`, {
            method: "POST",
            headers: {
              "content-type": "application/json",
              ...(options.headers ?? {}),
            },
            body: JSON.stringify({ key, params }),
          });

          if (!res.ok) {
            throw new Error(`RPC failed (${res.status}): ${await res.text()}`);
          }

          return (await res.json()) as RpcResponses[K];
        }
      TS
    end

    def build_interface_names(structs)
      by_basename = structs.group_by { |s| s.name.split('::').last }
      by_basename.each_with_object({}) do |(basename, klasses), hash|
        if klasses.length == 1
          hash[klasses.first.name] = basename
        else
          klasses.each do |k|
            hash[k.name] = k.name.gsub('::', '_')
          end
        end
      end
    end

    def interface_name_for(klass)
      @interface_names&.fetch(klass.name, klass.name.split('::').last) || klass.name.split('::').last
    end

    def map_type(type)
      return "any" if type.nil?
      return "null" if type == NilClass

      if defined?(Lazuli::Types)
        if type.is_a?(Lazuli::Types::Nilable)
          return "#{map_type(type.type)} | null"
        end

        if type.is_a?(Lazuli::Types::ArrayOf)
          return "#{map_type(type.type)}[]"
        end

        if type.is_a?(Lazuli::Types::Union)
          mapped = type.types.map { |t| map_type(t) }.compact.uniq
          return "any" if mapped.empty?
          return mapped.first if mapped.size == 1
          return mapped.join(" | ")
        end
      end

      # Back-compat: Array means array-of, optionally nullable array if NilClass included.
      if type.is_a?(Array)
        mapped = type.map { |t| map_type(t) }.compact.uniq
        return "any" if mapped.empty?

        null_part = mapped.delete("null") ? " | null" : ""
        return "#{mapped.first}[]#{null_part}" if mapped.size == 1
        return "(#{mapped.join(' | ')})[]#{null_part}"
      end

      TYPE_MAP.each do |ruby_type, ts_type|
        return ts_type if type <= ruby_type rescue false
      end

      return "any[]" if type == Array

      if defined?(Lazuli::Struct) && type.respond_to?(:<) && type < Lazuli::Struct
        return interface_name_for(type)
      end

      "any"
    end
  end
end
